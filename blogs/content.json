{"meta":{"title":"Haoxuan's Blog","subtitle":"","description":"","author":"Haoxuan Xie","url":"https://haoxuanxie.github.io/blogs","root":"/blogs/"},"pages":[],"posts":[{"title":"The Pisano period of C-finite sequences","slug":"pisano-period","date":"2024-10-21T11:54:25.000Z","updated":"2024-10-21T12:41:04.245Z","comments":true,"path":"2024/10/21/pisano-period/","permalink":"https://haoxuanxie.github.io/blogs/2024/10/21/pisano-period/","excerpt":"","text":"Problem definitionThe Pisano period of a prime , is defined as the minimum integer satisfying , where is the Fibonacci sequence. It is well known that for , is either a divisor of or . In this article, we extend this conclusion to any C-finite sequence of the formulae , where is a constant. Closed form expressionAssume has a general form . Then we rewrite the recursive formulae as , which yields a characteristic equation . Let be the characteristic roots. Assume , W.L.O.G., We claim that: Proof: since and , Pisano periodAs aforementioned, the characteristic roots should satisfy or . If $\\exists w\\in\\mathbb{Z}pw^2\\equiv a^2+4(\\operatorname{mod} p)2\\lambda_1-a\\equiv w2\\lambda_2-a\\equiv-w\\lambda_1,\\lambda_2\\in\\mathbb{Z}p\\lambda_1^{p-1}\\equiv\\lambda_2^{p-1}\\equiv 1$f{n+p-1}\\equiv\\frac{\\lambda_1^{n+p-1}-\\lambda_2^{n+p-1}}{\\lambda_1-\\lambda_2}\\equiv\\frac{\\lambda_1^n-\\lambda_2^n}{\\lambda_1-\\lambda_2}\\equiv f{n}$$ which implies that the Pisano period . If such that , we claim that . Proof: since are the roots of the equation , and . Let . Then: Note that and . Therefore, by Fermeat’s little theorem: By quadratic reciprocity, , then: Then and . Similarly, we can prove by assuming . Therefore:","categories":[],"tags":[]},{"title":"Graph coloring with densest subgraph","slug":"graph-coloring","date":"2024-10-12T16:01:06.000Z","updated":"2024-10-12T16:41:08.749Z","comments":true,"path":"2024/10/13/graph-coloring/","permalink":"https://haoxuanxie.github.io/blogs/2024/10/13/graph-coloring/","excerpt":"","text":"Problem definitionAn undirected graph is -coloring if all vertices could be colored with at most different colors, such that all adjacent vertices have different colors. For example, a -clique is -coloring, and a tree is 2-coloring. The densest subgraph of a graph , is an induced subgraph of a vertex subset of with vertices and edges, such that its density (i.e., ) is highest among all induced subgraphs. In this article, we aim to prove that for a graph whose densest subgraph has a density , it is -coloring. ProofLet and . We prove it by induction. When , and the graph is 1-coloring. Assume we have proved the case for . For any graph such that , we denote as the vertex set of its densest subgraph and assume its density is . Then we remove the smallest degree vertex of and derives a graph with vertices, which is proved to be -coloring and is the largest density of the new graph. Obviously, the degree of is no larger than . Otherwise, the total degree of all vertices in is larger than , which yields a density larger than . Therefore, can be colored with at most colors (if only considering its neighbours). We claim that . Then is -coloring (note that if a graph is -coloring and , then it is also -coloring). We prove it by contradiction. If , removing results in some induced subgraph with a larger density. However, by definition, the densest subgraph of is already the induced subgraph with the highest density. Therefore, it is impossible to find a denser subgraph by removing a vertex in . By induction, the proof is done. Finding a coloring schemeWe recursively remove the smallest degree vertex in . Specifically, we maintain a min-heap storing the degrees of all vertices. Initially, we insert all vertices into the heap. For each round, we extract the minimum degree vertex from the heap and remove the vertex. During the remove process, we need to update the degree of its neighbors (for a simple graph, the new degree of its neighbors should be ) and adjust the heap. With a binary heap, since extracting each vertex and updating the degree of each vertex is , and there are updates in total, the time complexity would be . With a Fibonacci heap, where decrease-key function could be done in , the time complexity would reduce to . We record the sequence of removing vertices, i.e., the algorithm removes sequentially. To construct the coloring scheme, we reversely consider each vertex: let be an empty graph. We firstly add to and color it with . Then we add to and its corresponding edges in connecting (if exist). If are connected, we color with . Otherwise, it is colored with . Similarly, we add to and its edges to if exist, and color with the minimum possible color. Repeat this process until is inserted into and colored. The time complexity of this process is bounded by . Therefore, the total time complexity of the algorithm is bounded by , and it is straightforward to prove its correctness using the similar technique in the induction proof.","categories":[],"tags":[]},{"title":"Maintaining the diameter of a growing tree in O(log n) time","slug":"diameter","date":"2024-09-03T10:57:20.000Z","updated":"2024-09-03T11:52:53.186Z","comments":true,"path":"2024/09/03/diameter/","permalink":"https://haoxuanxie.github.io/blogs/2024/09/03/diameter/","excerpt":"","text":"A tree is a connected undirected graph with nodes and edges. The diameter of a tree is the largest distance between two nodes in the tree. We define a growing tree as follows: at each moment, a new node is inserted into the tree, and is connected to some node in the original tree. What is the diameter of the new tree? Let be the path such that the length of is the diameter of the original tree. A key observation is that if are the endpoints of , then for the new tree, the endpoints of the new path for the new diameter must be or . The proof is rather simple. The distance between is actually the length of . By the definition of the tree diameter, it is also the largest distance between two nodes in the original tree. Since the distances between two nodes do not change in the original and new tree, the only candidate nodes to be the new endpoints could only be (for other nodes, since they have the same distances which are not larger than , we could just ignore them). Therefore, to derive the new diamter, we only need to maintain for each moment, and compute the distances between and after each moment, where the largest distance is the new diameter. The distance between could be computed by , where is the depth of the node and is the lowest common ancestor of two nodes, and other distances could be computed similarly. The depth of the new node could be maintained in time for each moment. Maintaining and computing could be done in time for each moment. As a result, we could maintain the diameter of a growing tree in time.","categories":[],"tags":[]},{"title":"The XOR sum of 4x, 4x + 1, 4x + 2 and 4x + 3 is 0 for any non-negative integer x","slug":"xorsum","date":"2024-09-02T13:19:05.000Z","updated":"2024-09-03T10:51:36.507Z","comments":true,"path":"2024/09/02/xorsum/","permalink":"https://haoxuanxie.github.io/blogs/2024/09/02/xorsum/","excerpt":"","text":"In this article, we would use to represent the bitwise XOR operation between two integers. We observe that: for any , , and therefore, for any . We now illustrate the formal proof of the above observation. We firstly write into a binary format, i.e.: Let . Then: Then the binary formats of are: Since the most significant bits of all aforementioned numbers are the same, the XOR sum of this part should be 0. For the latter bits, i.e., the 2 least significant bits, it is easy to compute that: Therefore, , and the proof is done.","categories":[],"tags":[]},{"title":"Welcome to my blog!","slug":"hello","date":"2024-09-02T13:19:04.000Z","updated":"2024-09-03T10:50:07.477Z","comments":true,"path":"2024/09/02/hello/","permalink":"https://haoxuanxie.github.io/blogs/2024/09/02/hello/","excerpt":"","text":"In my very early ages, I have planned to set up a personal blog. However, all my personal blogs were discarded either because I felt tired to maintain it or I felt nobody was going to read my posts. And as you see, this is my another attempt, and I would try my best to maintain this blog for this time. I know some of you may be my friends or you just come from my homepage. Different from my homepage which highlights my research publications, this blogs would record some personal thoughts, and some interesting ideas that may be too trivial to publish a paper. I may publish posts in multiple fields, including maths, computer science and so on (if I learn something new in the future). The thoughts may be quite random, and I would try to keep the posts brief to avoid them from being messed up. Initially, I want to start my blog page with sharing of personal experiences. But, I don’t know whether everyone would be interested in it. Therefore, the welcome page ends here, and I would fill in more contents via subsequent posts.","categories":[],"tags":[]}],"categories":[],"tags":[]}